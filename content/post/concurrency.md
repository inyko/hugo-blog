+++
comments = true
date = "2015-04-14T00:34:31+08:00"
draft = true
image = ""
imageurl = "https://41.media.tumblr.com/c52fec0a8ad4c1ddb6d93870290619d7/tumblr_nmcb5higeE1tqgztwo3_1280.jpg"
tags = []
title = "Concurrency Hot!"

+++
Concurrency——并发,这个词在近两年编程界真是 Hot 到不行，自己最近也是闲着空下来看了一些有关并发技术相关的资料，借着博客整理一下自己所了解到的那些主流并发技术。

###什么是并发？
说到并发（concurrency），不得不又提到一个词：并行（parallel）。一般在 CS 系的操作系统课程中一定会提到这两个的区别。  
搬出字典解释：  

**并发：又称共行，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。
并行：是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。**

没理解的话我们来看个例子就明白了：  

假设现在有一条单行道，这个单行道上有 5 个车道，每个车道一分钟会通过 30 辆车。  
pic  
那么这样的情况我们就可以称这里的 5 个车道是**并行**运作的，忽略一些细节，那么一分钟能通过的车辆数为 5×30=150。把一分钟看作一个单位时间的话，那么这个单行道的吞吐率是 150。

接下来我们看并发的情况，还是单行道，不过我们把车道减少到1条  
pic
但是假设这条车道一分钟能通过150量车，那么这条单行道的吞吐率同样是 150，以一分钟为单位时间考虑那么就可以认定这通过的 150 量车是**并发**的。

**通过上面的例子我们就可以了解到，并发关注的是宏观上的一个对任务的一个吞吐量，而不在乎具体某一时刻两个任务是否有同时发生。  
并发在宏观上达到和并行一样的吞吐量，那么我们就可以在编程里写逻辑并行的任务，具体的实现交给更下层的模块。**

### 提高并发的关键
如何追求高并发这个问题，其实本质上就是如何提高单位时间内数据的处理速度（好像有点废话的感觉，不过事实就是如此）。

早期的电脑，cpu 都是单核的，某一时刻下只能有一个任务被cpu所执行。值得注意的是，你在用浏览器上网的时候，旁边的 QQ 并没有停止运作，依然能收发消息，两者似乎看上去是独立运行的。事实上，在单核 cpu 下，浏览器和 QQ 都是通过**某种调度规则**，轮流被执行，只是因为他们切换的非常快以至于以人类的反应神经无法察觉。这就是并发所体现的结果。

#####调度规则（scheduling）
操作系统中还有一组重要概念：进程和线程。简单地讲，一个进程是由一个或一个以上的线程组成的，而进程本身是操作系统对于不同任务划分资源的分割单位。线程是进程的子集，所以属于更小的划分单位。  
而那些**调度规则**作用于线程，使得这些线程具有并发性。  
调度规则有各种各样：无脑的先进先出（First in first out,FIFO）、时间上较平均的时间片轮转（Round-robin）等等。规则具体的实现不在这里讨论，我们直接看一些结论：  
一个好的调度规则始终致力于如何更“公平”地分配 cpu 资源，越是“公平”的调度规则，其产生的结果就是更好的并发性，更高的吞吐量。  
这个“公平”，说的具体点就是：需要时间长的，优先级高的任务获得 cpu 资源比别的任务更多一点。

#### I/O —— 拖后腿的家伙
以上是理论部分，而在计算机实际应用中我们会发现一个很普遍的现象：cpu 的处理速度是快的，很多情况下是过剩的，而真正导致慢的罪魁祸首其实是在数据存取（Input/Output，I/O），I/O 慢直接导致了 cpu 空转。这个问题是由硬件的物理特性所导致的，越是快的存储单元价格越是昂贵。  
所以面对这样的现实，计算机攻城师们常年以来一直在把提高 I/O 作为提高计算机性能的首要研究课题。前文提到的调度规则，除了应用在实现多线程，还被应用在 I/O 调度，而且 I/O 调度对计算机性能的整体影响比多线程更为明显。


- - -

**以上就是有关并发在现代计算机中一些最底层的认识，了解以上概念有助于理解接下来提高并发的思路和技术。**

### 线程池——减少启用线程所带来的延时
##### 为什么需要线程池
理想情况下，有多少个可以逻辑上并行运行的任务，那么我们就开多少个线程来处理这些逻辑。不过……事实并没有那么理想，前面提到了 I/O 的能力远低于 CPU 处理能力的客观情况……而每次启动一个线程都需要等待资源就绪才能使用，并没有做到**随叫随到**。进程也一样，而且启用进程的时间要比线程更多。

对于这个问题，先人门想到的方法是预分配，在处理事务之前先启用一堆线程，而这堆线程给它一个形象的名字叫**线程池**。这堆线程在一开始都是闲着的，没有任何实质任务在运行。等到有任务的时候，把任务逻辑塞到某个闲着的线程中。这样的好处就是预先分配占用了线程资源，等到要用的时候能**随叫随到**。

在实际应用中，大名鼎鼎的 Apache HTTP server，就用了这种思路去处理请求，一般对应一个请求启用一个线程处理。

##### 线程池的问题
线程池使用的第一个问题就是如果任务太多满了怎么办？这时候有两种做法：1）启用新线程，扩大线程池。2）先等着，排队，有空位再来。3）就像多线程调度那样用的太久的家伙踢到后面，然新的任务进来。

使用进程池还有个头痛的问题，那就是初始化的时候该创建多大的线程池？这是个问题蛋疼的问题……建大了，空着的就浪费了……建小了，不够用就又得浪费时间等待……


### 异步——另一种解决 I/O 问题的新思路。
这两年 Node.js 可谓是火了一把，对 Node 来说，一个重要的关键词就是异步，异步是一种提高 I/O 非常有效的方法，所以 Node 吸引了大量的程序员。

#####  何为异步？
